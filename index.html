
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>コピ＆ペースト管理（テキスト＋画像／ファイル対応）</title>
  <style>
    :root {
      --bg: #0b0c10; --panel: #15171d; --panel-2: #1e212a; --text: #e8eef7; --muted: #a9b3c1;
      --primary: #4da3ff; --primary-2: #2b7ee5; --danger: #ff5c5c; --border: #2a2f3a; --ring: #4da3ff55; --radius: 12px;
    }
    @media (prefers-color-scheme: light) {
      :root { --bg:#f6f7fb; --panel:#fff; --panel-2:#f3f5f9; --text:#111827; --muted:#4b5563; --primary:#2563eb; --primary-2:#1e40af; --danger:#dc2626; --border:#e5e7eb; --ring:#2563eb33; }
    }
    *{box-sizing:border-box}
    body{margin:0;color:var(--text);background:var(--bg);font:14px/1.6 system-ui,"Noto Sans JP","Hiragino Sans","Yu Gothic UI",sans-serif}
    header{position:sticky;top:0;z-index:10;background:color-mix(in oklab,var(--bg) 88%,transparent);backdrop-filter:blur(6px);border-bottom:1px solid var(--border)}
    .wrap{max-width:980px;margin:0 auto;padding:16px}
    .title-row{display:flex;align-items:center;gap:12px;justify-content:space-between;flex-wrap:wrap}
    h1{margin:0;font-size:18px;font-weight:700}
    .badge{font-size:12px;color:var(--muted);border:1px solid var(--border);padding:3px 8px;border-radius:999px}
    .actions{display:flex;gap:10px}
    button{appearance:none;border:1px solid var(--border);background:var(--panel);color:var(--text);padding:9px 14px;border-radius:10px;cursor:pointer;transition:120ms background,120ms transform,120ms box-shadow}
    button:focus-visible{outline:none;box-shadow:0 0 0 3px var(--ring)}
    .btn-primary{background:linear-gradient(180deg,color-mix(in oklab,var(--primary) 96%,white 4%),var(--primary-2));color:#fff;border:none}
    .btn-ghost{background:var(--panel-2)}
    .btn-danger{background:color-mix(in oklab,var(--danger) 85%,black 5%);color:#fff;border:none}
    main{max-width:980px;margin:16px auto 64px;padding:0 16px}
    .list{display:flex;flex-direction:column;gap:10px}
    .item{background:linear-gradient(180deg,var(--panel),color-mix(in oklab,var(--panel) 80%,black 5%));border:1px solid var(--border);border-radius:var(--radius);padding:10px;display:grid;gap:10px;grid-template-columns:34px 1fr auto;align-items:stretch;box-shadow:0 3px 14px #00000022}
    .item.dragging{opacity:.6;border-style:dashed}
    .handle{display:flex;align-items:center;justify-content:center;user-select:none;width:34px;height:100%;border-radius:8px;background:var(--panel-2);border:1px dashed var(--border);cursor:grab}
    .handle:active{cursor:grabbing}
    .handle .icon{font-size:18px;letter-spacing:2px;color:var(--muted)}
    textarea.text{width:100%;min-height:84px;resize:vertical;padding:10px 12px;color:var(--text);background:var(--panel-2);border:1px solid var(--border);border-radius:10px;outline:none;transition:120ms border-color,120ms box-shadow}
    textarea.text:focus{border-color:var(--primary);box-shadow:0 0 0 3px var(--ring)}
    .btns{display:flex;align-items:start;gap:8px;flex-wrap:wrap}
    .btn-small{padding:8px 12px;border-radius:9px}
    .muted{color:var(--muted);font-size:12px}
    .preview{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .thumb{max-width:420px;max-height:220px;border-radius:10px;border:1px solid var(--border);background:var(--panel-2);object-fit:contain}
    .filecard{display:flex;align-items:center;gap:10px;background:var(--panel-2);border:1px solid var(--border);border-radius:10px;padding:10px 12px}
    .filemeta{font-size:13px;color:var(--muted)}
    @media (max-width:720px){.item{grid-template-columns:28px 1fr}.btns{grid-column:1/-1}.handle{width:28px}}
    .toast{position:fixed;left:50%;bottom:22px;transform:translateX(-50%) translateY(16px);background:var(--panel);border:1px solid var(--border);color:var(--text);padding:10px 14px;border-radius:10px;box-shadow:0 8px 26px #0000003a;opacity:0;pointer-events:none;transition:160ms opacity,200ms transform;z-index:50}
    .toast.show{opacity:1;transform:translateX(-50%) translateY(0)}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    .pill{font-size:11px;padding:2px 8px;border-radius:999px;border:1px solid var(--border);background:var(--panel-2);color:var(--muted)}
    /* 追記: ドロップ受け入れ中の強調 */
  /*.drop-active {
    outline: 3px dashed var(--primary);
    outline-offset: 6px;
    border-radius: 14px;
  }*/
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="title-row">
      <h1>コピ＆ペースト管理 <span id="store-badge" class="badge">Saving…</span></h1>
      <div class="actions">
        <button id="add-text" class="btn btn-primary">＋ 追加</button>
        <button id="add-from-clipboard" class="btn btn-ghost">📋 クリップボードから取り込む</button>
      </div>
    </div>
    <div class="muted" style="margin-top:6px">
  左端の≡をドラッグで並べ替え／編集・追加・並べ替えは自動保存（IndexedDB）。
</div>
  </div>
</header>

<main>
  <div id="list" class="list" aria-live="polite"></div>
</main>

<!-- テキスト用 -->
<template id="tpl-text">
  <div class="item" data-id="" data-kind="text">
    <div class="handle" role="button" aria-label="ドラッグして並べ替え"><span class="icon">≡</span></div>
    <textarea class="text" placeholder="ここにテキストを入力／ペースト…"></textarea>
    <div class="btns">
      <button class="btn btn-small btn-ghost copy-btn">コピー</button>
      <button class="btn btn-small btn-danger del-btn">削除</button>
    </div>
  </div>
</template>

<!-- 画像用 -->
<template id="tpl-image">
  <div class="item" data-id="" data-kind="image">
    <div class="handle" role="button" aria-label="ドラッグして並べ替え"><span class="icon">≡</span></div>
    <div class="preview">
      <img class="thumb" alt="画像プレビュー" />
      <div class="filemeta"></div>
    </div>
    <div class="btns">
      <button class="btn btn-small btn-ghost copy-btn">クリップボードへ</button>
      <a class="btn btn-small btn-ghost dl-btn" download>ダウンロード</a>
      <button class="btn btn-small btn-danger del-btn">削除</button>
    </div>
  </div>
</template>

<!-- 汎用ファイル用 -->
<template id="tpl-file">
  <div class="item" data-id="" data-kind="file">
    <div class="handle" role="button" aria-label="ドラッグして並べ替え"><span class="icon">≡</span></div>
    <div class="filecard">
      <div style="font-size:22px">📄</div>
      <div>
        <div class="filename"></div>
        <div class="filemeta"></div>
      </div>
    </div>
    <div class="btns">
      <button class="btn btn-small btn-ghost copy-btn">クリップボードへ</button>
      <a class="btn btn-small btn-ghost dl-btn" download>ダウンロード</a>
      <button class="btn btn-small btn-danger del-btn">削除</button>
    </div>
  </div>
</template>

<div id="toast" class="toast" role="status" aria-live="polite">完了</div>
<div id="sr-live" class="sr-only" aria-live="polite"></div>

<script>
/** ========= 基本設定 ========= */
const DB_NAME = 'CopyPasteManager';
const DB_VERSION = 2;        // ★ 画像/ファイル対応でスキーマバージョンUP
const STORE = 'state';
const STATE_KEY = 'v2';
const LS_KEY = 'copyPasteManagerStateV2';

const KINDS = { TEXT:'text', IMAGE:'image', FILE:'file' };

/** ========= 小道具 ========= */
const $ = (s, r=document)=>r.querySelector(s);
const $$ = (s, r=document)=>Array.from(r.querySelectorAll(s));
const uuid = () => (crypto.randomUUID?.() ?? `id-${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`);
const fmtBytes = (n)=> {
  if (n < 1024) return `${n} B`;
  if (n < 1024**2) return (n/1024).toFixed(1)+ ' KB';
  if (n < 1024**3) return (n/1024**2).toFixed(1)+ ' MB';
  return (n/1024**3).toFixed(1)+ ' GB';
};
function toast(msg){ const el=$('#toast'); el.textContent=msg; el.classList.add('show'); setTimeout(()=>el.classList.remove('show'),1200); $('#sr-live').textContent=msg; }

/** ========= ストレージ（IndexedDB / localStorage） ========= */
let storageMode = 'idb';
let idb = null;

function updateStoreBadge(){ const badge=$('#store-badge'); badge.textContent = storageMode==='idb'?'IndexedDB':'localStorage'; }
function openDB(){
  return new Promise((res,rej)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE, {keyPath:'key'});
    };
    req.onsuccess = ()=>res(req.result);
    req.onerror = ()=>rej(req.error||new Error('IndexedDB open error'));
  });
}
async function prepareStorage(){
  try { idb = await openDB(); storageMode='idb'; }
  catch(e){ console.warn('IndexedDB不可。localStorageへ', e); storageMode='ls'; }
  updateStoreBadge();
}
async function loadState(){
  if (storageMode==='idb'){
    try{
      const {result} = await new Promise((res,rej)=>{
        const tx=idb.transaction(STORE,'readonly'); const st=tx.objectStore(STORE);
        const rq = st.get(STATE_KEY);
        rq.onsuccess = ()=>res({result: rq.result?.value});
        rq.onerror = ()=>rej(rq.error);
      });
      return result ?? { items: [] };
    }catch{ return { items: [] }; }
  }else{
    try{ const raw=localStorage.getItem(LS_KEY); return raw? JSON.parse(raw): {items:[]}; }
    catch{ return {items:[]}; }
  }
}
async function saveState(state){
  if (storageMode==='idb'){
    await new Promise((res,rej)=>{
      const tx=idb.transaction(STORE,'readwrite'); const st=tx.objectStore(STORE);
      const rq = st.put({ key: STATE_KEY, value: state, ts: Date.now() });
      rq.onsuccess = ()=>res(); rq.onerror = ()=>rej(rq.error);
    }).catch(e=>console.error('保存失敗',e));
  }else{
    try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }
    catch(e){ console.error('localStorage保存失敗',e); }
  }
}

/** ========= アプリ状態 =========
 * state.items = [{ id, kind, text? , blob? , name?, type?, size? }]
 */
let state = { items: [] };

function persist(){ return saveState(state); }

/** ========= DOM生成 ========= */
function addTextItem({id=uuid(), text=""}={}){
  state.items.push({id, kind:KINDS.TEXT, text});
  const el = renderTextItem({id, text});
  persist(); return el;
}
function renderTextItem({id, text}){
  const node = $('#tpl-text').content.firstElementChild.cloneNode(true);
  node.dataset.id = id;
  const ta = $('.text', node);
  ta.value = text;
  ta.addEventListener('input', ()=>{
    const it = state.items.find(x=>x.id===id);
    if (it) it.text = ta.value;
    persist();
  });
  $('.copy-btn', node).addEventListener('click', ()=> copyText(ta.value));
  $('.del-btn', node).addEventListener('click', ()=> removeItem(id));
  setupDrag(node);
  $('#list').appendChild(node);
  return node;
}

function addImageItem({id=uuid(), blob, name, type}){
  const size = blob.size;
  state.items.push({id, kind:KINDS.IMAGE, blob, name:name||'image', type:type||blob.type, size});
  const el = renderImageItem({id, blob, name, type, size});
  persist(); return el;
}
function renderImageItem({id, blob, name, type, size}){
  const node = $('#tpl-image').content.firstElementChild.cloneNode(true);
  node.dataset.id = id;
  const url = URL.createObjectURL(blob);
  $('.thumb', node).src = url;
  $('.filemeta', node).textContent = `${name || 'image'}  •  ${type || blob.type}  •  ${fmtBytes(size||blob.size)}`;
  const dl = $('.dl-btn', node);
  dl.href = url; dl.download = name || 'image';
  $('.copy-btn', node).addEventListener('click', ()=> copyBlobToClipboard(blob, type||blob.type));
  $('.del-btn', node).addEventListener('click', ()=> { URL.revokeObjectURL(url); removeItem(id); });
  setupDrag(node);
  $('#list').appendChild(node);
  return node;
}

function addFileItem({id=uuid(), blob, name, type}){
  const size = blob.size;
  state.items.push({id, kind:KINDS.FILE, blob, name:name||'file', type:type||blob.type||'application/octet-stream', size});
  const el = renderFileItem({id, blob, name, type, size});
  persist(); return el;
}
function renderFileItem({id, blob, name, type, size}){
  const node = $('#tpl-file').content.firstElementChild.cloneNode(true);
  node.dataset.id = id;
  $('.filename', node).textContent = name || 'file';
  $('.filemeta', node).textContent = `${type || blob.type || 'application/octet-stream'}  •  ${fmtBytes(size||blob.size)}`;
  const url = URL.createObjectURL(blob);
  const dl = $('.dl-btn', node);
  dl.href = url; dl.download = name || 'file';
  $('.copy-btn', node).addEventListener('click', ()=> copyBlobToClipboard(blob, type||blob.type||'application/octet-stream'));
  $('.del-btn', node).addEventListener('click', ()=> { URL.revokeObjectURL(url); removeItem(id); });
  setupDrag(node);
  $('#list').appendChild(node);
  return node;
}

function setupDrag(node){
  const handle = $('.handle', node);
  handle.addEventListener('pointerdown', ()=>{ node.draggable = true; }, {passive:true});
  node.addEventListener('dragstart', (e)=>{ node.classList.add('dragging'); e.dataTransfer?.setData('text/plain', node.dataset.id); e.dataTransfer?.setDragImage(new Image(),0,0); });
  node.addEventListener('dragend', ()=>{ node.classList.remove('dragging'); node.draggable=false; reorderStateFromDOM(); persist(); });
}
$('#list').addEventListener('dragover', (e)=>{
  e.preventDefault();
  const list = e.currentTarget;
  const dragging = $('.item.dragging', list); if (!dragging) return;
  const after = getAfterElement(list, e.clientY);
  if (after==null) list.appendChild(dragging); else list.insertBefore(dragging, after);
});
function getAfterElement(container, y){
  const els = $$('.item:not(.dragging)', container);
  let closest = {offset:Number.NEGATIVE_INFINITY, el:null};
  for (const el of els){
    const box=el.getBoundingClientRect(); const offset = y - (box.top + box.height/2);
    if (offset < 0 && offset > closest.offset) closest = {offset, el};
  }
  return closest.el;
}
function reorderStateFromDOM(){
  const ids = $$('.item', $('#list')).map(el=>el.dataset.id);
  state.items.sort((a,b)=> ids.indexOf(a.id) - ids.indexOf(b.id));
}
function removeItem(id){
  const idx = state.items.findIndex(x=>x.id===id);
  if (idx>=0) state.items.splice(idx,1);
  const el = $(`.item[data-id="${id}"]`); if (el) el.remove();
  persist();
}

/** ========= クリップボード連携 ========= */
async function copyText(text){
  try{
    if (navigator.clipboard?.writeText) await navigator.clipboard.writeText(text);
    else legacyCopyText(text);
    toast('テキストをコピーしました');
  }catch(e){ console.warn(e); toast('コピーに失敗しました'); }
}

// 差し替え版：Explorer貼り付けは仕様上不可のため、可能な形式（画像PNG / テキスト）でコピー。
// それが無理・失敗なケースでは "プレーンテキスト" をクリップボードに保存します。
async function copyBlobToClipboard(blob, mime, filename = 'file') {
  const type = mime || blob.type || 'application/octet-stream';
  const isImage = /^image\//i.test(type);
  const isLikelyText =
    /^text\//i.test(type) ||
    /(json|xml|csv|yaml|yml|markdown|md|javascript|ecmascript|html|svg\+xml)$/i.test(type);

  // 返り値で「Explorerに貼り付けられるか」を明示（常に false）
  const result = { ok: false, explorerPasteable: false };

  try {
    // 画像は PNG に正規化してコピー（Paint 等には貼り付け可、Explorer は不可）
    if (isImage && navigator.clipboard?.write && window.ClipboardItem) {
      const png = await toPngBlob(blob);
      await navigator.clipboard.write([new ClipboardItem({ 'image/png': png })]);
      toast('画像をクリップボードへコピーしました（PNG）。※Explorerには貼り付けできません');
      result.ok = true;
      return result;
    }

    // テキスト系は中身をプレーンテキストでコピー（メモ帳等には貼り付け可、Explorer は不可）
    if (isLikelyText) {
      const text = await blob.text().catch(async () => await blobToPlainText(blob, type));
      await copyTextFallbackAware(text);
      toast('テキストをクリップボードへコピーしました。※Explorerには貼り付けできません');
      result.ok = true;
      return result;
    }

    // それ以外（PDF/Office/ZIPなど）は、ブラウザ仕様上 Explorer へ「ファイルとして」貼り付け不可。
    // まずは ClipboardItem で原本タイプのまま挑戦（他アプリでの貼り付けに効く場合あり）
    if (navigator.clipboard?.write && window.ClipboardItem) {
      try {
        await navigator.clipboard.write([new ClipboardItem({ [type]: blob })]);
        // 成功しても Explorer フォルダ貼り付けは不可
        toast('ファイルをクリップボードへコピーしました。※Explorerには貼り付けできません');
        result.ok = true;
        return result;
      } catch {
        // 失敗時はプレーンテキスト（中身）でフォールバック
        const text = await blobToPlainText(blob, type);
        await copyTextFallbackAware(text);
        toast('ブラウザ未対応のため、中身のプレーンテキストをコピーしました');
        result.ok = true;
        return result;
      }
    } else {
      // ClipboardItem 未対応 → プレーンテキストへ
      const text = await blobToPlainText(blob, type);
      await copyTextFallbackAware(text);
      toast('ブラウザ未対応のため、中身のプレーンテキストをコピーしました');
      result.ok = true;
      return result;
    }
  } catch (err) {
    console.warn('clipboard write failed:', err);
    // 最終フォールバック：プレーンテキスト
    try {
      const text = await blobToPlainText(blob, type);
      await copyTextFallbackAware(text);
      toast('中身のプレーンテキストをコピーしました');
      result.ok = true;
      return result;
    } catch {
      toast('コピーに失敗しました');
      return result;
    }
  }
}

/* ---- ヘルパ ---- */

// 画像→PNG Blob 変換
async function toPngBlob(srcBlob) {
  if ((srcBlob.type || '').toLowerCase() === 'image/png') return srcBlob;
  const dataUrl = await new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = () => res(r.result);
    r.onerror = rej;
    r.readAsDataURL(srcBlob);
  });
  const img = await new Promise((res, rej) => {
    const i = new Image();
    i.onload = () => res(i);
    i.onerror = rej;
    i.src = dataUrl;
  });
  const canvas = document.createElement('canvas');
  canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  return await new Promise((res) => canvas.toBlob(res, 'image/png'));
}

// Blob → プレーンテキスト（UTF-8としてデコード／制御文字を除去）
async function blobToPlainText(blob, mime = '') {
  // 明確に text/* なら素直に
  if (/^text\//i.test(mime)) {
    try { return await blob.text(); } catch { /* 続行 */ }
  }
  const buf = await blob.arrayBuffer();
  const decoder = new TextDecoder('utf-8', { fatal: false });
  let txt = decoder.decode(buf);
  // 制御文字（\t,\n,\r 以外）を削除して可読性を担保
  txt = txt.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
  return txt;
}

// writeText or レガシーフォールバック
async function copyTextFallbackAware(text) {
  if (navigator.clipboard?.writeText) return navigator.clipboard.writeText(text);
  legacyCopyText(text);
}

// レガシーな選択コピー
function legacyCopyText(text) {
  const ta = document.createElement('textarea');
  ta.value = text;
  ta.style.position = 'fixed';
  ta.style.left = '-9999px';
  document.body.appendChild(ta);
  ta.focus(); ta.select();
  document.execCommand('copy');
  document.body.removeChild(ta);
}

/** ========= 取り込み（★ 修正: 画像／ファイル対応） ========= */
async function addFromClipboard(){
  // 1) まず read() を試す（複合アイテム対応）
  if (navigator.clipboard?.read){
    try{
      const items = await navigator.clipboard.read();
      let added = 0;
      for (const it of items){
        // テキスト優先
        if (it.types.includes('text/plain')){
          const blob = await it.getType('text/plain');
          const text = await blob.text();
          addTextItem({ text }); added++; continue;
        }
        // 画像
        const imgType = it.types.find(t=>t.startsWith('image/'));
        if (imgType){
          const blob = await it.getType(imgType);
          addImageItem({ blob, name:'clipboard-image', type:imgType }); added++; continue;
        }
        // その他（先頭タイプを採用）
        if (it.types.length){
          const t = it.types[0];
          const blob = await it.getType(t);
          addFileItem({ blob, name:`clipboard-${t.replace('/','-')}`, type:t }); added++; continue;
        }
      }
      if (added>0){ toast(`${added}件取り込みました`); return; }
      // itemsはあったが適切に処理できなかった場合 → readTextへ
    }catch(e){
      console.warn('clipboard.read 失敗、readTextへフォールバック', e);
    }
  }
  // 2) readText フォールバック（テキストのみ）
  try{
    const text = await navigator.clipboard.readText();
    if (text && text.trim().length){
      addTextItem({ text }); toast('テキストを取り込みました');
    }else{
      toast('クリップボードに取り込める内容がありません');
    }
  }catch(e){
    console.warn(e); toast('クリップボードの読み取りに失敗しました');
  }
}

/** ========= 復元描画 ========= */
function renderAll(){
  $('#list').innerHTML = '';
  for (const it of state.items){
    if (it.kind===KINDS.TEXT) renderTextItem(it);
    else if (it.kind===KINDS.IMAGE) renderImageItem(it);
    else renderFileItem(it);
  }
}

/** ========= 初期化 ========= */
async function init(){
  await prepareStorage();
  state = await loadState();
  if (!state?.items) state = { items: [] };
  if (state.items.length===0) addTextItem({ text:'' }); else renderAll();

  $('#add-text').addEventListener('click', ()=> addTextItem({ text:'' }));
  $('#add-from-clipboard').addEventListener('click', addFromClipboard);
  window.addEventListener('paste', handlePasteFiles);

  const dropTarget = $('#list');
  dropTarget.addEventListener('dragover', handleDragOver);
  dropTarget.addEventListener('dragleave', handleDragLeave);
  dropTarget.addEventListener('drop', handleDropFiles);
}

// ★ 追記：貼り付けで files を取り込む（Chromeで有効）
  function handlePasteFiles(e){
    const dt = e.clipboardData;
    if (!dt) return;
    const files = Array.from(dt.files || []);
    if (!files.length) return;

    let added = 0;
    for (const f of files){
      // f は File（Blobのサブクラス）
      if (f.type && f.type.startsWith('image/')) {
        addImageItem({ blob: f, name: f.name || 'image', type: f.type });
      } else {
        addFileItem({ blob: f, name: f.name || 'file', type: f.type || 'application/octet-stream' });
      }
      added++;
    }
    if (added) {
      e.preventDefault(); // 画像がページに貼り付いてしまうのを防止
      persist().then(()=> toast(`${added}件 貼り付けで取り込みました`));
    }
  }

// ★ 追記：D&D 取り込み（ページ全体でOKだが、#list をドロップターゲットに）
  function handleDropFiles(e){
    e.preventDefault();
    const dt = e.dataTransfer;
    const files = Array.from(dt?.files || []);
    if (!files.length) return;

    let added = 0;
    for (const f of files){
      if (f.type && f.type.startsWith('image/')) {
        addImageItem({ blob: f, name: f.name || 'image', type: f.type });
      } else {
        addFileItem({ blob: f, name: f.name || 'file', type: f.type || 'application/octet-stream' });
      }
      added++;
    }
    if (added) {
      persist().then(()=> toast(`${added}件 ドロップで取り込みました`));
    }
    //$('#list').classList.remove('drop-active');
  }

  function handleDragOver(e){
    // ファイルを受け取れることを明示
    if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
    e.preventDefault();
    //$('#list').classList.add('drop-active');
  }

  function handleDragLeave(){
    //$('#list').classList.remove('drop-active');
  }

init();
</script>
</body>
</html>
